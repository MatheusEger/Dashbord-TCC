"""
Este script realiza autenticação na Plexa API e coleta dados de um endpoint protegido,
com suporte tanto para requisições únicas quanto em lote.

Funcionalidades:
- Realiza login na Plexa API com e-mail e senha pré-configurados.
- Obtém um token de acesso para autenticar as requisições.
- Permite realizar uma requisição única a um endpoint específico.
- Suporta requisições em lote para múltiplos tickers, respeitando limites de taxa da API.
  - Divide a lista de tickers em grupos conforme o limite de requisições por minuto.
  - Aguarda automaticamente entre os lotes para não exceder o limite da API.
- Os dados obtidos são armazenados na variável `DADOS_OBTIDOS` e exibidos no console.

Como usar:
- Substitua `SEU_EMAIL_AQUI` e `SUA_SENHA_AQUI` pelas suas credenciais da Plexa API.
- Ajuste `LISTA_DE_TIKERS`, `MESES_DESEJADO`, `MAX_REQUISICOES` e `INTERVALO_REQUISICOES` conforme sua necessidade e plano de acesso.

Avisos:
- Este script é fornecido "como está". O uso é por sua conta e risco.
- Mantenha suas credenciais seguras e nunca as compartilhe.
- O uso da API deve estar de acordo com os Termos de Serviço da Plexa API.

Autores:
- Vlademir de Souza Bergamini

Última atualização:
- 05/06/2025

Contato:
- ctt@plexa.com.br
"""

import requests
import json
import time

LOGIN_ENDPOINT = 'https://api.plexa.com.br/site/login'  # Endpoint de login
ENDPOINT_DESEJADO = 'https://api.plexa.com.br/site/dividendo'  # Endpoint desejado
MESES_DESEJADO = 12  # quantidade de meses desejado
LISTA_DE_TIKERS = ['AFHI11', 'BTLG11', 'CACR11', 'CRAA11', 'CPSH11', 'CDII11', 'HGRU11'] # Lista de exemplo
MAX_REQUISICOES = 50  # Limite de requisições por minuto [Apoiador 50, Premium 100]
INTERVALO_REQUISICOES = 61  # segundos
EMAIL = 'SEU_EMAIL_AQUI'  # Substituir por seu e-mail
SENHA = 'SUA_SENHA_AQUI'  # Substituir por sua senha
TOKEN = None
DADOS_OBTIDOS = []

# Fazer o login
login_data = {
    'usuEmail': EMAIL,
    'usuSenha': SENHA,
}

login_headers = {
    'Content-Type': 'application/json'
}

response = requests.post(LOGIN_ENDPOINT, headers=login_headers, json=login_data)

if response.status_code == 200:
    data = response.json()
    if 'accessToken' in data:
        TOKEN = data['accessToken'] # Seu token estará aqui
    else:
        print(data.get('msg', 'Erro desconhecido no login')) # Em caso de Erro retorna o motivo
else:
    print(f'Erro no login: {response.status_code}')
    exit()

if TOKEN:
    # Este bloco realiza uma única requisição no endpoint desejado.
    if ENDPOINT_DESEJADO == 'https://api.plexa.com.br/json/fundo': # Este endpoint retorna os dados atuais de todos os fundos cadastrados
        headers = {
            'Authorization': f'Bearer {TOKEN}',
            'Content-Type': 'application/json'
        }

        response = requests.get(ENDPOINT_DESEJADO, headers=headers)

        if response.status_code == 200:
            r = response.json()
            if r.get('ok'):
                DADOS_OBTIDOS = r.get('data') # Os dados estarão aqui
                print(json.dumps(DADOS_OBTIDOS, indent=4))
            else:
                print(r.get('msg'))
        else:
            print(f'Erro na requisição: {response.status_code}')
    else:
        # Este bloco realiza requisições em lotes em intervalos de "n" requisições por minuto
        def process_batch(tickers):
            resultados = []
            for ticker in tickers:
                try:
                    url = f"{ENDPOINT_DESEJADO}/{ticker}/{MESES_DESEJADO}"
                    r = requests.get(url, headers={
                        "Authorization": f"Bearer {TOKEN}",
                        "Content-Type": "application/json"
                    })
                    r_json = r.json()
                    if r_json.get("ok"):
                        resultados.append(r_json["data"])
                    else:
                        print(f"Erro em {ticker}: {r_json.get('msg', 'Erro na requisição')}")
                        resultados.append(None)
                except Exception as e:
                    print(f"Erro em {ticker}: {e}")
                    resultados.append(None)
            return resultados

        # Processar lotes com intervalo
        for i in range(0, len(LISTA_DE_TIKERS), MAX_REQUISICOES):
            batch = LISTA_DE_TIKERS[i:i + MAX_REQUISICOES]
            dados_batch = process_batch(batch)
            DADOS_OBTIDOS.extend(dados_batch) # Os dados estarão aqui

            print(json.dumps(dados_batch, indent=4))

            if i + MAX_REQUISICOES < len(LISTA_DE_TIKERS):
                time.sleep(INTERVALO_REQUISICOES)

# Daqui em diante você pode trabalar à vontade com a variável DADOS_OBTIDOS.